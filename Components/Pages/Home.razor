@page "/"

@using MudBlazor

@code {
    private List<Service> Services = new();
    private System.Timers.Timer? Timer;
    private string SelectedStatus = "All";
    private string SearchText = "";
    private readonly List<string> StatusOptions = new() { "All", "Online", "Offline" };

    protected override void OnInitialized()
    {
        // 初期サービスデータ
        Services = new List<Service>
        {
            new Service { Name = "Web API", IP = "192.168.1.10", IsRunning = true },
            new Service { Name = "Database", IP = "192.168.1.20", IsRunning = false },
            new Service { Name = "Cache", IP = "192.168.1.30", IsRunning = true }
        };

        // タイマーで状態を定期更新
        Timer = new System.Timers.Timer(1000); // 1秒ごとに更新
        Timer.Elapsed += (sender, e) => UpdateStatus();
        Timer.AutoReset = true;
        Timer.Start();
    }

    private void UpdateStatus()
    {
        var now = DateTime.Now;
        foreach (var service in Services)
        {
            bool previousState = service.IsRunning;
            service.IsRunning = new Random().Next(0, 2) == 0;

            if (!service.IsRunning)
            {
                if (previousState)
                {
                    service.DownSince = now; // ダウンした瞬間の時間を記録
                }
            }
            else
            {
                service.DownSince = null; // オンラインになったらリセット
            }
        }
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        Timer?.Dispose();
    }

    private List<Service> FilteredServices => Services
        .Where(s => (SelectedStatus == "All" || (SelectedStatus == "Online" && s.IsRunning) || (SelectedStatus == "Offline" && !s.IsRunning)))
        .Where(s => string.IsNullOrEmpty(SearchText) || s.Name.Contains(SearchText, StringComparison.OrdinalIgnoreCase) || s.IP.Contains(SearchText))
        .ToList();

    private class Service
    {
        public string Name { get; set; } = "";
        public string IP { get; set; } = "";
        public bool IsRunning { get; set; }
        public DateTime? DownSince { get; set; } // 赤ランプ（ダウン状態）の開始時刻

        public string DownDuration => !IsRunning && DownSince != null
            ? (DateTime.Now - DownSince.Value).ToString(@"hh\:mm\:ss")
            : "";
    }
}

<style>
    .filter-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
        margin-bottom: 10px;
    }

        .filter-container .mud-input,
        .filter-container .mud-select {
            width: 200px;
        }

    .status-lamp {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 10px;
    }

    .online {
        background-color: #00ff00;
        box-shadow: 0px 0px 15px #00ff00;
    }

    .offline {
        background-color: #ff0000;
        box-shadow: 0px 0px 15px #ff0000;
    }

</style>

<h1 style="text-align:center; margin-top: 20px;">🔥 サーバーステータス 🔥</h1>

<div class="filter-container">
    <MudTextField Class="mud-input" Label="Search" @bind-Value="SearchText" Adornment="Adornment.Start" Variant="Variant.Outlined" />
    <MudSelect Class="mud-select" @bind-Value="SelectedStatus" Label="Status" Variant="Variant.Outlined">
        @foreach (var status in StatusOptions)
        {
            <MudSelectItem Value="@status">@status</MudSelectItem>
        }
    </MudSelect>
</div>

<MudTable Items="FilteredServices" Hover="true" Dense="true" Sortable="true" FixedHeader="true" Height="500px" Breakpoint="Breakpoint.None">
    <HeaderContent>
        <MudTh Style="width: 5%;"></MudTh>
        <MudTh Style="width: 30%;">Service Name</MudTh>
        <MudTh Style="width: 30%;">IP Address</MudTh>
        <MudTh Style="width: 20%;">Status</MudTh>
        <MudTh Style="width: 15%;">Down Time</MudTh>
    </HeaderContent>
    <RowTemplate Context="service">
        <MudTd>
            <span class="status-lamp @(service.IsRunning ? "online" : "offline")"></span>
        </MudTd>
        <MudTd>@service.Name</MudTd>
        <MudTd>@service.IP</MudTd>
        <MudTd>
            <MudChip T="string" Color="@(service.IsRunning ? Color.Success : Color.Error)">
                @(service.IsRunning ? "Online" : "Offline")
            </MudChip>
        </MudTd>
        <MudTd>@(service.DownDuration)</MudTd>
    </RowTemplate>
</MudTable>



<PageTitle>Home</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Hello, world!</MudText>
<MudText Class="mb-8">Welcome to your new app, powered by MudBlazor and the .NET 9 Template!</MudText>

<MudAlert Severity="Severity.Normal">
    You can find documentation and examples on our website here:
    <MudLink Href="https://mudblazor.com" Target="_blank" Typo="Typo.body2" Color="Color.Primary">
        <b>www.mudblazor.com</b>
    </MudLink>
</MudAlert>

<br />
<MudText Typo="Typo.h5" GutterBottom="true">Interactivity in this Template</MudText>
<br />
<MudText Typo="Typo.body2">
    When you opt for the "Global" Interactivity Location, <br />
    the render modes are defined in App.razor and consequently apply to all child components.<br />
    In this case, providers are globally set in the MainLayout.<br />
    <br />
    On the other hand, if you choose the "Per page/component" Interactivity Location,<br />
    it is necessary to include the <br />
    <br />
    &lt;MudPopoverProvider /&gt; <br />
    &lt;MudDialogProvider /&gt; <br />
    &lt;MudSnackbarProvider /&gt; <br />
    <br />
    components on every interactive page.<br />
    <br />
    If a render mode is not specified for a page, it defaults to Server-Side Rendering (SSR),<br />
    similar to this page. While MudBlazor allows pages to be rendered in SSR,<br />
    please note that interactive features, such as buttons and dropdown menus, will not be functional.
</MudText>

<br />
<MudText Typo="Typo.h5" GutterBottom="true">What's New in Blazor with the Release of .NET 9</MudText>
<br />

<MudText Typo="Typo.h6" GutterBottom="true">Prerendering</MudText>
<MudText Typo="Typo.body2" GutterBottom="true">
    If you're exploring the features of .NET 9 Blazor,<br /> you might be pleasantly surprised to learn that each page is prerendered on the server,<br /> regardless of the selected render mode.<br /><br />
    This means that you'll need to inject all necessary services on the server,<br /> even when opting for the wasm (WebAssembly) render mode.<br /><br />
    This prerendering functionality is crucial to ensuring that WebAssembly mode feels fast and responsive,<br /> especially when it comes to initial page load times.<br /><br />
    For more information on how to detect prerendering and leverage the RenderContext, you can refer to the following link:
    <MudLink Href="https://github.com/dotnet/aspnetcore/issues/51468#issuecomment-1783568121" Target="_blank" Typo="Typo.body2" Color="Color.Primary">
        More details
    </MudLink>
</MudText>

<br />
<MudText Typo="Typo.h6" GutterBottom="true">InteractiveAuto</MudText>
<MudText Typo="Typo.body2">
    A discussion on how to achieve this can be found here:
    <MudLink Href="https://github.com/dotnet/aspnetcore/issues/51468#issue-1950424116" Target="_blank" Typo="Typo.body2" Color="Color.Primary">
        More details
    </MudLink>
</MudText>
